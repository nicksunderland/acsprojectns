# Index event

## Installation
```{r installation_index}
library(acsprojectns)
library(devtools)
load_all()
library(icdb)
library(modeest)
library(kableExtra)
```
## Index ACS event
```{r index_acs_diagnoses, results="markup"}
# all the diagnosis codes from the episodes within the index spell
index_acs_diagnoses <- msrv$sus$apc_spells_diagnosis |>
  # Only cohort NHS numbers
  dplyr::filter(nhs_number %in% cohort_ids) |>
  # Time window
  dplyr::filter(spell_start >= acs_date_min & spell_end <= acs_date_max) |>
  # select the needed columns
  dplyr::select(nhs_number, start=spell_start, end=spell_end, 
                dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd")) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, spell_start, spell_end), by="nhs_number") |>
  # make sure that the spell overlaps the index spell 
  dplyr::filter(lubridate::int_overlaps(int1 = lubridate::interval(start, end),
                                        int2 = lubridate::interval(spell_start, spell_end))) |>
  # ensure all columns characters
  dplyr::mutate(dplyr::across(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                              ~ as.character(.x))) |>
  # pivot diagnoses to long format
  tidyr::pivot_longer(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                      names_to="diag_pos",
                      values_to="diagnosis", 
                      values_drop_na=TRUE) |>
  # only take id, spell dates and diagnoses
  dplyr::select(nhs_number, spell_start, spell_end, diagnosis) |>
  # Recode the ICD10 codes
  dplyr::mutate(diagnosis = icdb::icd10(diagnosis, 
                                        system.file("icd10_codes", "icd10_ns.yaml", package="acsprojectns"))) %>% 
  # Make sure ICD10 codes are all valid
  {if(all(icdb::is_valid(.$diagnosis))) . else stop("error1 - couldn't parse all the ICD codes")} |>
  # pivot wider, one column per diagnosis
  dplyr::mutate(diagnosis_str = dplyr::if_else(icdb::group_string(diagnosis)!="",
                                               icdb::group_string(diagnosis), 
                                               as.character(diagnosis)), 
                value=TRUE) |>
    # separate the groups if there are multiple
  tidyr::separate_longer_delim(diagnosis_str, delim=",") |>
  # only allow one of each diagnosis per patient
  dplyr::group_by(nhs_number, diagnosis_str) |>
  dplyr::distinct(nhs_number, diagnosis_str, value) |>
  # one column per diagnsis; fill in NAs with FALSE
  tidyr::pivot_wider(names_from=diagnosis_str, values_from=value) |>
  # replace any injected NAs with FALSE
  dplyr::mutate(dplyr::across(dplyr::everything(), ~tidyr::replace_na(.x, FALSE)))
  
```

## Index ACS admission procedures
```{r index_acs_procedure, results="markup"}
# read in the code mappnigs for angiograms, PCI, and coronary artery bypass
opcs_angio_codes <- read.csv(system.file("opcs_codes/coronary_angiogram_procedure_codes.csv", package = "acsprojectns"))
opcs_pci_codes   <- read.csv(system.file("opcs_codes/pci_procedure_codes.csv", package = "acsprojectns"))
opcs_cabg_codes  <- read.csv(system.file("opcs_codes/cabg_procedure_codes.csv", package = "acsprojectns"))
opcs_codes       <- rbind(opcs_angio_codes, opcs_pci_codes, opcs_cabg_codes)

index_acs_procedures <- msrv$sus$apc_spells_procedures |>
  # Only cohort NHS numbers
  dplyr::filter(nhs_number %in% cohort_ids) |>
  # Time window
  dplyr::filter(spell_start >= acs_date_min & spell_end <= acs_date_max) |>
  # select the needed columns
  dplyr::select(nhs_number, start=spell_start, end=spell_end, dplyr::contains("procedure")) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, spell_start, spell_end), by="nhs_number") |>
  # make sure that the spell overlaps the index spell 
  dplyr::filter(lubridate::int_overlaps(int1 = lubridate::interval(start, end),
                                        int2 = lubridate::interval(spell_start, spell_end))) |>
  dplyr::select(nhs_number, dplyr::contains("procedure")) |>
  dplyr::mutate(dplyr::across(dplyr::everything(), as.character)) |>
  tidyr::pivot_longer(-nhs_number, names_to=c("procedure", ".value"), names_pattern="(.*)_(\\w+)") |>
  dplyr::left_join(opcs_codes, by=c("opcs"="opcs_codes")) |>
  dplyr::filter(!is.na(group)) |>
  dplyr::select(-c(procedure, opcs, description)) |>
  dplyr::group_by(nhs_number, group) |>
  dplyr::slice_min(date, with_ties=FALSE) |>
  tidyr::pivot_wider(names_from=group, values_from=date) |>
  dplyr::right_join(data.frame("nhs_number"=cohort_ids), by="nhs_number")
```

## Index ACS admission
```{r index_acs_main, results="markup"}
index_acs_main <- index_acs |>
  dplyr::select(nhs_number, spell_start, spell_end, primary_diagnosis, critical_care_days) |>
  dplyr::mutate(length_of_stay = lubridate::time_length(lubridate::interval(spell_start, spell_end), unit="days")) |>
  dplyr::left_join(index_acs_diagnoses, by="nhs_number") |>
  dplyr::left_join(index_acs_procedures, by="nhs_number") |>
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, cambridge), by="nhs_number")
```

## ACS type
```{r index_acs_type, results="markup"}
# Overall
index_acs_main |>
  dplyr::summarise(dplyr::across(dplyr::where(is.numeric), ~mean(.x, na.rm=T)),
                   dplyr::across(dplyr::where(is.logical), ~sum(.x)/dplyr::n())) |>
  t()

# By ACS diagnosis
index_acs_main |>
  dplyr::group_by(icdb::group_string(primary_diagnosis)) |>
  dplyr::summarise(dplyr::across(dplyr::where(is.numeric), ~mean(.x, na.rm=T)),
                   dplyr::across(dplyr::where(is.logical), ~sum(.x)/dplyr::n())) |>
  t()

# By frailty score
index_acs_main |>
  dplyr::group_by(cambridge) |>
  dplyr::summarise(dplyr::across(dplyr::where(is.numeric), ~mean(.x, na.rm=T)),
                   dplyr::across(dplyr::where(is.logical), ~sum(.x)/dplyr::n())) |>
  t()
```


