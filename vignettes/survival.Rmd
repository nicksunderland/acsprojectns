# Survival

## Installation
```{r installation_survival}
library(acsprojectns)
library(devtools)
load_all()
library(icdb)
library(modeest)
library(kableExtra)
library(survival)
library(survminer)
library(wesanderson)
```

## Subsequent events - deaths
```{r deaths, results="markup"}
# get all of the subsequent diagnoses after the start point of the index ACS event
death_events <- msrv$mort$civil_reg |> 
  # Only cohort NHS numbers
  dplyr::filter(nhs_number %in% cohort_ids, 
                !is.na(date_of_death)) |>
  # # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # pivot longer
  dplyr::mutate(dplyr::across(-c(nhs_number, date_of_death, place_of_death_ccg_code, place_of_death), as.character)) |>
  tidyr::pivot_longer(-c(nhs_number, date_of_death, place_of_death_ccg_code, place_of_death), 
                      names_to=c("icd_code", ".value"), 
                      names_pattern="(.*)_(\\w+)", 
                      values_drop_na=TRUE) |>
  # recode the ICD10 codes
  dplyr::mutate(diagnosis = icdb::icd10(code, 
                                        system.file("icd10_codes", "icd10_ns.yaml", package="acsprojectns"))) %>% 
  # Make sure ICD10 codes are all valid
  {if(all(icdb::is_valid(.$diagnosis))) . else stop("error1 - couldn't parse all the ICD codes")} |>
  # filter out line "d", which I think corresponds to line "2" on the death certification - i.e.
  # conditions contributing but not causing the death; keep a, b, and c 
  dplyr::filter(line=="a"|line=="b"|line=="c") |>
  # extract diagnosis group or ICD string (if not listed as a group)
  dplyr::mutate(event_desc = dplyr::if_else(icdb::group_string(diagnosis)!="",
                                            icdb::group_string(diagnosis), 
                                            as.character(diagnosis))) |>
  # separate the groups if there are multiple
  tidyr::separate_longer_delim(event_desc, delim=",") |>
  # code as a death rather than the straight ICD10 code or grouping 
  dplyr::mutate(event_desc = paste0("death_", event_desc)) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, event_start=date_of_death, event_end=date_of_death)
```

```{r subsequent_diagnoses, results="markup"}
# get all of the subsequent diagnoses after the start point of the index ACS event
subsequent_diagnoses <- msrv$sus$apc_spells_diagnosis |>
  # Only cohort NHS numbers
  dplyr::filter(nhs_number %in% cohort_ids) |>
  # Time window - start of the cohort window to present
  dplyr::filter(spell_start >= acs_date_min) |>
  # select the needed columns - start and end now refer to the spell the diagnosis was made; whereas
  # spell_start and spell_end still refer to the index ACS spell
  dplyr::select(nhs_number, event_start=spell_start, event_end=spell_end, 
                dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd")) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), by="nhs_number") |>
  # make sure that the spell comes after (or at the same time as) the start of the index ACS spell
  dplyr::filter(event_start >= index_start) |>
  # ensure all columns characters
  dplyr::mutate(dplyr::across(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                              ~ as.character(.x))) |>
  # pivot diagnoses to long format
  tidyr::pivot_longer(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                      names_to="diag_pos",
                      values_to="diagnosis", 
                      values_drop_na=TRUE) |>
  # only take id, spell dates and diagnoses
  dplyr::select(nhs_number, index_start, index_end, event_start, event_end, diagnosis) |>
  # Recode the ICD10 codes
  dplyr::mutate(diagnosis = icdb::icd10(diagnosis, 
                                        system.file("icd10_codes", "icd10_ns.yaml", package="acsprojectns"))) %>% 
  # Make sure ICD10 codes are all valid
  {if(all(icdb::is_valid(.$diagnosis))) . else stop("error1 - couldn't parse all the ICD codes")} |>
  # extract diagnosis group or ICD string (if not listed as a group)
  dplyr::mutate(event_desc = dplyr::if_else(icdb::group_string(diagnosis)!="",
                                            icdb::group_string(diagnosis), 
                                            as.character(diagnosis))) |>
  # separate the groups if there are multiple
  tidyr::separate_longer_delim(event_desc, delim=",") |>
  # filter out diagnoses that cannot be subsequent events - e.g. we cannot have an ACS subsequent
  # event happening within the index ACS spell (this is the index ACS event)
  dplyr::filter(!(event_desc %in% c("acs_stemi", "acs_nstemi", "acs_unstable_angina") & 
                    #TODO: ?add cardiomyopathy diagnoses too?
                    # is an ACS and is within the index spell
                  lubridate::`%within%`(a=lubridate::interval(event_start,event_end), 
                                        b=lubridate::interval(index_start,index_end)))) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, event_start, event_end)
```

```{r subsequent_events, results="markup"}
# combined
all_subsequent_events <- dplyr::bind_rows(subsequent_diagnoses, death_events) |>
  # keep all the nhs numbers represented
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), 
                    by=c("nhs_number")) |>
  # create the latest follow up
  dplyr::left_join(death_events |> 
                     dplyr::select(nhs_number, date_of_death=event_start) |>
                     dplyr::group_by(nhs_number) |>
                     dplyr::slice_min(date_of_death, with_ties=FALSE), by=c("nhs_number")) |>
  #TODO: add in max follow up from SWD rather than just assuming today's date
  dplyr::mutate(last_fu = dplyr::if_else(!is.na(date_of_death), date_of_death, Sys.Date())) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, index_start, index_end, event_start, event_end, last_fu)

```

## Survival - all-cause death
## Table - cause of death (in first 12 months)
```{r all_cause_death, results="markup"}

outcome_groupings = list("any_death" = "^death", 
                         "acs" = "^acs")

foo <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings)


```

## Survival - all-cause admission back to hospital
## Table - re-admission diagnosis (in first 12 months)
```{r all_cause_readmission, results="markup"}

outcome_groupings = list("any_admission" = "^(?!death).*$")

any_readmission <- acsprojectns::create_survival_timings(all_subsequent_events |> 
                                               dplyr::filter(event_end>index_end | is.na(event_end)), outcome_groupings)

# Create the Survival object - for any readmission
surv_tt_obj_any_read <- survival::Surv(any_readmission$tstart, any_readmission$tstop, any_readmission$status)
# surv_gt_obj_any_read <- survival::Surv(rep(0, length(any_readmission$tstart)), any_readmission$tstop-any_readmission$tstart, any_readmission$status)

# Survival table
summary(survfit(surv_tt_obj_any_read ~ 1, data=any_readmission))

# Plot 
km_plot_any_readmission <- ggsurvplot(fit = surv_fit(surv_tt_obj_any_read ~ 1, data=any_readmission),
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = wes_palette("Darjeeling1", 2),
           censor.shape ="",
           xlab = "Time from index ACS event",
           ylab = "Freedom from hospital admission",
           legend       = c(0.75,0.90),
           legend.title = "",
           legend.labs = c("Test"),
           ggtheme      = theme_classic())
```

## Survival - MACCE

## Table - MACCE diagnoses (in first 12 months)

## Cox PH model of factors affecting death and re-admission
Is frailty the main driver? If so...

## Survival by frailty score

