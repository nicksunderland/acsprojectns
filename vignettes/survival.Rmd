# Survival

## Installation
```{r installation_survival}
library(acsprojectns)
library(devtools)
load_all()
library(icdb)
library(kableExtra)
library(survival)
library(survminer)
library(wesanderson)
library(viridis)
```

## Subsequent events - deaths
```{r deaths, results="markup"}
# get all of the deaths after the start point of the index ACS event
death_events <- msrv$mort$civil_reg %>% 
  # Only cohort NHS numbers
  {if(.Platform$OS.type == "windows") {
    dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
  } else {
    dplyr::filter(., nhs_number %in% cohort_ids)
  }} |>
  # Only cohort NHS numbers
  dplyr::filter(!is.na(date_of_death)) |>
  # # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # pivot longer
  dplyr::mutate(dplyr::across(-c(nhs_number, date_of_death, place_of_death_ccg_code, place_of_death), as.character)) |>
  tidyr::pivot_longer(-c(nhs_number, date_of_death, place_of_death_ccg_code, place_of_death), 
                      names_to=c("icd_code", ".value"), 
                      names_pattern="(.*)_(\\w+)", 
                      values_drop_na=TRUE) |>
  # recode the ICD10 codes
  dplyr::mutate(diagnosis = icdb::icd10(code, 
                                        system.file("icd10_codes", "icd10_ns.yaml", package="acsprojectns"))) %>% 
  # Make sure ICD10 codes are all valid
  {if(all(icdb::is_valid(.$diagnosis))) . else stop("error1 - couldn't parse all the ICD codes")} |>
  # filter out line "d", which I think corresponds to line "2" on the death certification - i.e.
  # conditions contributing but not causing the death; keep a, b, and c 
  dplyr::filter(line=="a"|line=="b"|line=="c") |>
  # extract diagnosis group or ICD string (if not listed as a group)
  dplyr::mutate(event_desc = dplyr::if_else(icdb::group_string(diagnosis)!="",
                                            icdb::group_string(diagnosis), 
                                            as.character(diagnosis))) |>
  # separate the groups if there are multiple
  tidyr::separate_longer_delim(event_desc, delim=",") |>
  # code as a death rather than the straight ICD10 code or grouping 
  dplyr::mutate(event_desc = paste0("death_", event_desc)) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, event_start=date_of_death, event_end=date_of_death)
```

```{r subsequent_diagnoses, results="markup"}
admission_code_map <- acsprojectns::get_codes(system.file("admission_method_codes/admission_method_codes.csv", package="acsprojectns")) |>
  dplyr::mutate(adm_method_str = dplyr::case_when(grepl("emergency", admission_method_description) ~ "emergency",
                                                  grepl("elective", admission_method_description) ~ "elective",
                                                  TRUE ~ "other")) |>
  dplyr::select(admission_method_code, adm_method_str)

# get all of the subsequent diagnoses after the end point of the index ACS event
subsequent_diagnoses <- msrv$sus$apc_spells_diagnosis %>% 
  # Only cohort NHS numbers
  {if(.Platform$OS.type == "windows") {
    dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
  } else {
    dplyr::filter(., nhs_number %in% cohort_ids)
  }} |>
  # Time window - start of the cohort window to present
  dplyr::filter(spell_start >= acs_date_min) |>
  # select the needed columns - start and end now refer to the spell the diagnosis was made; whereas
  # spell_start and spell_end still refer to the index ACS spell
  dplyr::select(nhs_number, event_start=spell_start, event_end=spell_end, method_of_admission_hospital_provider_spell,
                dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd")) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(method_of_admission_hospital_provider_spell = as.character(method_of_admission_hospital_provider_spell)) |>
  # recode admission method 
  dplyr::left_join(admission_code_map, by=c("method_of_admission_hospital_provider_spell"="admission_method_code")) |>
  # shouldnt need to do this at work 
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), by="nhs_number") |>
  # make sure that the spell comes after the end of the index ACS spell
  dplyr::filter(event_start > index_end) |>
  #dplyr::filter(event_start >= index_start) |>
  # ensure all columns characters
  dplyr::mutate(dplyr::across(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                              ~ as.character(.x))) |>
  # pivot diagnoses to long format
  tidyr::pivot_longer(dplyr::matches("primary_diagnosis_icd|secondary_diagnosis_[0-9]+_icd"),
                      names_to="diag_pos",
                      values_to="diagnosis", 
                      values_drop_na=TRUE) |>
  # only take id, spell dates and diagnoses
  dplyr::select(nhs_number, index_start, index_end, event_start, event_end, diagnosis, adm_method_str) |>
  # Recode the ICD10 codes
  dplyr::mutate(diagnosis = icdb::icd10(diagnosis, 
                                        system.file("icd10_codes", "icd10_ns.yaml", package="acsprojectns"))) %>% 
  # Make sure ICD10 codes are all valid
  #{if(all(icdb::is_valid(.$diagnosis))) . else stop("error1 - couldn't parse all the ICD codes")} |>
  # Make sure ICD10 codes are all valid
  dplyr::filter(icdb::is_valid(diagnosis)) |>
  # extract diagnosis group or ICD string (if not listed as a group)
  dplyr::mutate(event_desc = dplyr::if_else(icdb::group_string(diagnosis)!="",
                                            icdb::group_string(diagnosis), 
                                            as.character(diagnosis))) |>
  # separate the groups if there are multiple
  tidyr::separate_longer_delim(event_desc, delim=",") |>
  # add in the admission method - emergency or elective
  dplyr::mutate(event_desc = paste0(event_desc, "_", adm_method_str)) |>
  
  # filter out diagnoses that cannot be subsequent events - e.g. we cannot have an ACS subsequent
  # event happening within the index ACS spell (this is the index ACS event)
  dplyr::filter(
    # event is not in this list AND
    !(grepl(paste0(c("acs_stemi", "acs_nstemi", "acs_unstable_angina", "isch_cardiomyopathy", "cardiac_arrest", "heart_failure", "nonisch_cardiomyopathy"), collapse = "|"), event_desc) & 
    # is an ACS and is within the index spell
    lubridate::`%within%`(a=lubridate::interval(event_start,event_end), 
                          b=lubridate::interval(index_start,index_end)))) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, event_start, event_end)
```

```{r subsequent_procedures, results="markup"}
# read in the code mappnigs for angiograms, PCI, and coronary artery bypass
opcs_angio_codes <- read.csv(system.file("opcs_codes/coronary_angiogram_procedure_codes.csv", package = "acsprojectns"))
opcs_pci_codes   <- read.csv(system.file("opcs_codes/pci_procedure_codes.csv", package = "acsprojectns"))
opcs_cabg_codes  <- read.csv(system.file("opcs_codes/cabg_procedure_codes.csv", package = "acsprojectns"))
opcs_codes       <- rbind(opcs_angio_codes, opcs_pci_codes, opcs_cabg_codes)

subsequent_procedures <- msrv$sus$apc_spells_procedures %>% 
  # Only cohort NHS numbers
  {if(.Platform$OS.type == "windows") {
    dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
  } else {
    dplyr::filter(., nhs_number %in% cohort_ids)
  }} |>
  # Time window - start of the cohort window to present
  dplyr::filter(spell_start >= acs_date_min) |>
  # select the needed columns
  dplyr::select(nhs_number, proc_spell_start=spell_start, proc_spell_end=spell_end, dplyr::contains("procedure"), method_of_admission_hospital_provider_spell) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work 
  dplyr::mutate(method_of_admission_hospital_provider_spell = as.character(method_of_admission_hospital_provider_spell)) |>
  # recode admission method 
  dplyr::left_join(admission_code_map, by=c("method_of_admission_hospital_provider_spell"="admission_method_code")) |>
  # shouldnt need to do this at work
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), by="nhs_number") |>
  # make sure that the spell comes after the end of the index ACS spell
  dplyr::filter(proc_spell_start > index_end) |>
  dplyr::select(-c(proc_spell_start, proc_spell_end)) |>
  #dplyr::filter(event_start >= index_start) |>
  # ensure all columns characters and empty character strings are NA
  dplyr::mutate(dplyr::across(dplyr::matches("procedure_(\\d+)_opcs"), ~ as.character(.x)),
                dplyr::across(dplyr::matches("procedure_(\\d+)_date"), ~ as.Date(.x)), 
                dplyr::across(dplyr::where(is.character), ~ dplyr::na_if(.x,""))) |>
  # pivot long
  tidyr::pivot_longer(-c(nhs_number, index_start, index_end, adm_method_str), names_to=c("procedure", ".value"), names_pattern="procedure_(\\d+)_(\\w+)", values_drop_na=TRUE) |>
  dplyr::left_join(opcs_codes, by=c("opcs"="opcs_codes")) |>
  dplyr::mutate(event_start = date, event_end = date) |>
  # extract procedure grouping / coding
  dplyr::mutate(event_desc = dplyr::if_else(!is.na(group), group, opcs), 
                event_desc = paste0(event_desc, "_", adm_method_str)) |>
  # only take id, spell dates and diagnoses
  dplyr::select(nhs_number, event_desc, event_start, event_end)
```

```{r subsequent_measurements, results="markup"}
subsequent_measurements <- msrv$swd$swd_measurement %>% 
  # Only cohort NHS numbers
  {if(.Platform$OS.type == "windows") {
    dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
  } else {
    dplyr::filter(., nhs_number %in% cohort_ids)
  }} |>
  # Time window - start of the cohort window to present
  dplyr::filter(measurement_date >= acs_date_min) |>
  # select the needed columns
  dplyr::select(nhs_number, event_start=measurement_date, event_end=measurement_date, measurement_value, measurement_name, measurement_group) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), by="nhs_number") |>
  # make sure that the spell comes after the end of the index ACS spell
  dplyr::filter(event_start > index_end) |>
  #dplyr::filter(event_start >= index_start) |>
  # extract procedure grouping / coding
  dplyr::mutate(event_desc = paste0(measurement_name, "_", measurement_value)) |>
  # only take id, spell dates and event description
  dplyr::select(nhs_number, event_desc, event_start, event_end)
```

```{r subsequent_prescriptions, results="markup"}
# Low dose statin therapy without ezetimibe - # low dose = simva 10, prava 10-20, lova 20, fluva 20-40, pitva 1            https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.uspharmacist.com%2Farticle%2Flipidlowering-therapies-a-review-of-current-and-future-options&psig=AOvVaw1oUjYp0LCmvmyKdwPQM3UM&ust=1649363828741000&source=images&cd=vfe&ved=0CAoQjRxqFwoTCMDY-pqlgPcCFQAAAAAdAAAAABAD
med_filter_string <- "(?i)([A-z ]+)(\\d+\\.?\\d*)?([A-z]+)?[ ]*(?:[A-z]*)"

subsequent_prescriptions <- msrv$swd$swd_prescription %>% 
  # Only cohort NHS numbers
  {if(.Platform$OS.type == "windows") {
    dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
  } else {
    dplyr::filter(., nhs_number %in% cohort_ids)
  }} |>
  # Time window - start of the cohort window to present; and only prescriptions
  dplyr::filter(prescription_date >= acs_date_min) |>
  # select the needed columns
  dplyr::select(nhs_number,
                event_start=prescription_date,
                event_end=prescription_date,
                prescription_name) |>
  # collect to local
  icdb::run() |>
  # shouldnt need to do this at work
  dplyr::mutate(nhs_number = as.character(nhs_number)) |>
  # join the index spell data
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), by="nhs_number") |>
  # make sure that the spell comes after the end of the index ACS spell
  dplyr::filter(event_start > index_end) |>
  #dplyr::filter(event_start >= index_start) |>
  # prescription grouping / coding
  dplyr::mutate(medication_name   = tolower(trimws(stringr::str_match(prescription_name, pattern = med_filter_string)[,2])),
                medication_dose   = stringr::str_match(prescription_name, pattern = med_filter_string)[,3],
                medication_units  = stringr::str_match(prescription_name, pattern = med_filter_string)[,4], 
                event_desc = dplyr::case_when(
                  grepl("inclisiran", medication_name) ~ "inclisiran", 
                  # High dose statin therapy
                  (grepl("atorvastatin", medication_name) & medication_dose>=40) |
                  (grepl("rosuvastatin", medication_name) & medication_dose>=20) |
                  (grepl("simvastatin",  medication_name) & medication_dose>=80) ~ "high_statin",
                  # Moderate dose statin therapy
                  (grepl("atorvastatin", medication_name) & medication_dose<40)  |
                  (grepl("rosuvastatin", medication_name) & medication_dose<20)  |
                  (grepl("fluvastatin",  medication_name) & medication_dose>40)  |
                  (grepl("pravastatin",  medication_name) & medication_dose>=40) |
                  (grepl("simvastatin",  medication_name) & medication_dose>=20) ~ "subopt_statin",
                  # Low dose statin therapy
                  (grepl("fluvastatin",  medication_name) & medication_dose<=40) |
                  (grepl("pravastatin",  medication_name) & medication_dose<40)  |
                  (grepl("simvastatin",  medication_name) & medication_dose<20) ~ "subopt_statin",
                  
                  TRUE ~ NA_character_)) |>
  # for now, just get rid of things that aren't statins
  dplyr::filter(!is.na(event_desc)) |>
  # only take id, spell dates and event description
  dplyr::select(nhs_number, event_desc, event_start, event_end)

```

```{r subsequent_events, results="markup"}
# combined
all_subsequent_events <- dplyr::bind_rows(subsequent_diagnoses,
                                          subsequent_procedures,
                                          subsequent_measurements,
                                          subsequent_prescriptions,
                                          death_events) |>
  # keep all the nhs numbers represented
  dplyr::right_join(index_acs |> dplyr::select(nhs_number, index_start=spell_start, index_end=spell_end), 
                    by=c("nhs_number")) |>
  # create the latest follow up  # adds 'date_of_death'
  dplyr::left_join(death_events |> 
                     dplyr::select(nhs_number, date_of_death=event_start) |>
                     dplyr::group_by(nhs_number) |>
                     dplyr::slice_min(date_of_death, with_ties=FALSE), by=c("nhs_number")) |>
  # add in max follow up from SWD rather than just assuming today's date; adds 'attribute_period'
  dplyr::left_join(msrv$swd$attr_h %>% 
                     # Only cohort NHS numbers; group by patient and take maximum attribute period
                      {if(.Platform$OS.type == "windows") {
                        dplyr::right_join(., data.frame("nhs_number" = cohort_ids), by="nhs_number", copy = TRUE) 
                      } else {
                        dplyr::filter(., nhs_number %in% cohort_ids)
                      }} |>
                     dplyr::group_by(nhs_number) |>
                     dplyr::slice_max(attribute_period, with_ties=FALSE) |>
                     dplyr::select(nhs_number, attribute_period) |>
                     icdb::run() |>
                     dplyr::mutate(nhs_number = as.character(nhs_number)), by="nhs_number") |>
  # TODO: add the max date from diagnoses and procedures
  
  dplyr::group_by(nhs_number) |>
  dplyr::mutate(last_data = dplyr::if_else(attribute_period>max(event_end) | is.na(event_end), attribute_period, max(event_end)), 
                last_fu   = dplyr::if_else(!is.na(date_of_death), date_of_death, last_data)) |>
  # clean up 
  dplyr::select(nhs_number, event_desc, index_start, index_end, event_start, event_end, last_fu)

```


## Survival - all-cause death


```{r all_cause_death, results="markup"}
# create the survival timings 
outcome_groupings = list("any_death" = "death")
any_death <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number")
# Create the Survival object - for any death
surv_tt_obj_any_read <- survival::Surv(any_death$tstart, any_death$tstop, any_death$status)
# Create the Survival object - for any death
surv_tt_obj <- survival::Surv(any_death$tstart, any_death$tstop, any_death$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + fudge_cambridge_segment, data=any_death)
# Survival table
survtbl <- summary(surv_fit)
# Plot 
km_plot_any_death <- ggsurvplot(
           fit          = surv_fit,
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = viridis(n=length(surv_fit$strata), option="inferno"),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           legend       = c(0.15,0.4),
           legend.title = "",
           legend.labs = paste0("Segment ", 1:5),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_any_death
```

## MACCE
MACCE is defined as a composite of cardiovascular mortality, recurrent myocardial infarction, and ischemic stroke.
```{r macce, results="markup"}
outcome_groupings = list("macce" = c("death_acs_[a-z]+", 
                                     "death_[a-z]+_cardiomyopathy",
                                     "death_heart_failure",
                                     "death_ischaemic_stroke",
                                     "death_ventricular_arrhy",
                                     "death_atrial_fib",
                                     "death_atrial_arrhy",
                                     "death_cardiomegaly",
                                     "death_periph_vasc_disease",
                                     "death_presence_of_coronary_stent",
                                     "death_presence_of_cabg",
                                     "death_presence_of_prosthetic_heart_valve",
                                     "death_presence_of_cied",
                                     "death_conduction_disease",
                                     "death_[a-z]+_valve_regurgitation",
                                     "death_[a-z]+_valve_stenosis",
                                     "death_cardiac_arrest", 
                                     "^acs_[a-z]+_[a-z]*_emergency$",
                                     "ischaemic_stroke",
                                     "^angiogram",
                                     "^pci", 
                                     "^cabg"))
macce <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number")
# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(macce$tstart, macce$tstop, macce$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + fudge_cambridge_segment, data=macce)
# Survival table
survtbl <- summary(surv_fit)
# Plot 
km_plot_macce <- ggsurvplot(
           fit          = surv_fit,
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = viridis(n=length(surv_fit$strata), option="inferno"),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           #xlim = c(0.0, 366.0),
           # legend       = c(0.7,0.3),
           # legend.title = "",
           # legend.labs = c("High dose statin", "Sub-optimal dose statin", "No statin", "Blanking window event"),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_macce
```


## Readmissions - all-cause emergency admission back to hospital
## Table - re-admission diagnosis (in first 12 months)
```{r all_cause_emergency_readmission, results="markup"}

# outcome_groupings = list("any_emergency_admission" = "emergency$")
# 
# any_readmission <- acsprojectns::create_survival_timings(
#   # only take events that happened after the end of the index spell OR patients with no events (as still need to represent these)
#   all_subsequent_events |> dplyr::filter(event_end>index_end | is.na(event_desc)), outcome_groupings) |> 
#   dplyr::left_join(index_acs_main |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number") |>
#   dplyr::mutate(tstop = dplyr::if_else(tstop==0|tstart==tstop, tstop+0.01, tstop))
# 
# # Create the Survival object - for any readmission
# surv_tt_obj_any_read <- survival::Surv(any_readmission$tstart, any_readmission$tstop, any_readmission$status)
# # surv_gt_obj_any_read <- survival::Surv(rep(0, length(any_readmission$tstart)), any_readmission$tstop-any_readmission$tstart, any_readmission$status)
# 
# # Survival table
# #summary(survfit(surv_tt_obj_any_read ~ 1, data=any_readmission))
# 
# # Plot 
# km_plot_any_readmission <- ggsurvplot(fit = surv_fit(surv_tt_obj_any_read ~ fudge_cambridge_segment, data=any_readmission),
#            surv.scale   = "percent",
#            xscale       = 365.25,
#            break.time.by= 365.25,
#            conf.int      = TRUE,
#            conf.int.alpha=0.25,
#            palette      = colorRampPalette(c("black", "red"))(5),
#            censor.shape ="",
#            xlab = "Time from index ACS event (years)",
#            ylab = "Freedom from emergency hospital admission",
#            ylim = c(0.0, 1.0),
#            legend       = c(0.15,0.4),
#            legend.title = "",
#            legend.labs = paste0("Segment ", 1:5),
#            ggtheme      = theme_classic())
# km_plot_any_readmission
```

## Readmissions - cardiovascular readmission
```{r cv_emergency_readmission}

# outcome_groupings = list("macce" = c("death", "^acs_", "stroke"))
# 
# any_readmission <- acsprojectns::create_survival_timings(
#   # only take events that happened after the end of the index spell OR patients with no events (as still need to represent these)
#   all_subsequent_events |> dplyr::filter(event_end>index_end | is.na(event_desc)), outcome_groupings) |> 
#   dplyr::filter(outcome=="macce")|>
#   dplyr::left_join(index_acs_main |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number")
# 
# # Create the Survival object - for any readmission
# surv_tt_obj_any_read <- survival::Surv(any_readmission$tstart, any_readmission$tstop, any_readmission$status)
# # surv_gt_obj_any_read <- survival::Surv(rep(0, length(any_readmission$tstart)), any_readmission$tstop-any_readmission$tstart, any_readmission$status)
# 
# # Survival table
# #summary(survfit(surv_tt_obj_any_read ~ 1, data=any_readmission))
# 
# # Plot 
# km_plot_any_readmission <- ggsurvplot(fit = surv_fit(surv_tt_obj_any_read ~ fudge_cambridge_segment, data=any_readmission),
#            surv.scale   = "percent",
#            xscale       = 365.25,
#            break.time.by= 365.25,
#            conf.int      = TRUE,
#            conf.int.alpha=0.25,
#            palette      = wes_palette("Darjeeling1", 5),
#            censor.shape ="",
#            xlab = "Time from index ACS event (years)",
#            ylab = "Freedom from hospital admission",
#            legend       = c(0.75,0.90),
#            legend.title = "",
#           # legend.labs = c("Test"),
#            ggtheme      = theme_classic())
# km_plot_any_readmission

```
## Table - CV readmission diagnoses (in first 12 months)


## Cox PH model of factors affecting death and re-admission
Is frailty the main driver? If so...




## Time to lipid prescription
```{r time_to_lipid_prescription, results="markup"}
outcome_groupings = list("any_lipid_lowering" = c("inclisiran", "high_statin", "subopt_statin"), 
                         "high_intensity" = c("inclisiran", "high_statin"),
                         "subopt_statin"  = "subopt_statin")
lipids <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number")

# Create the Survival object
surv_tt_obj <- survival::Surv(lipids$tstart, lipids$tstop, lipids$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome, data=lipids) #+ fudge_cambridge_segment
# Survival table
survtbl <- summary(surv_fit)
# Plot 
plot_lipids_prescription <- ggsurvplot(
           fit          = surv_fit,
           facet.by     = "fudge_cambridge_segment", 
           fun          = "event", 
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 30,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           #palette      = viridis(n=length(surv_fit$strata), option="inferno"),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           xlim = c(0.0, 366.0),
           # legend       = c(0.15,0.4),
           # legend.title = "",
           #legend.labs = paste0("Segment ", 1:5),
           #risk.table = TRUE,
           ggtheme      = theme_classic())
plot_lipids_prescription


```

## Cholesterol measurements
```{r when_did_we_start_collecting_cholesterol_data}
#TODO here work out when the first cholesterol test was in the whole swd; then filter on ACS events
#happening after this date then make sure to filter out people before this date in the survival
#analysis as they may falsely categorized as not having had their cholesterol checked


x=1
```


```{r time_to_cholesterol_measurement, results="markup"}

outcome_groupings = list("cholesterol_measurement" = c("cholesterol"))

cholesterol <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number")

#TODO filter out patients before the cholesterol data epoch



# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(cholesterol$tstart, cholesterol$tstop, cholesterol$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + fudge_cambridge_segment, data=cholesterol)
# Survival table
survtbl <- summary(surv_fit)
# Plot 
km_plot_chol <- ggsurvplot(
           fit          = surv_fit,
           fun          = "event", 
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 30,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = viridis(n=length(surv_fit$strata), option="inferno"),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           xlim = c(0.0, 366.0),
           # legend       = c(0.15,0.4),
           # legend.title = "",
           #legend.labs = paste0("Segment ", 1:5),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_chol
```


## lipid prescribing strategy
```{r lipid_prescribing_strategy, results="markup"}
# days from ACS event in which to look for prescribing data
lipid_strat_blanking = 120 
#lipid strategy
lipid_strat <- all_subsequent_events |>
  # only take statin prescription events
  dplyr::filter(grepl("statin", event_desc)) |>
  # only take prescription events within the blanking period
  dplyr::filter(event_start < (index_end + lubridate::duration(lipid_strat_blanking, units="days"))) |>
  # order by the most potent strategy and take that for each patient
  dplyr::mutate(event_desc = factor(event_desc, 
                                    levels = c("high_statin", "subopt_statin"),
                                    labels = c("high_statin", "subopt_statin"))) |>
  dplyr::group_by(nhs_number) |>
  dplyr::arrange(event_desc, .by_group=TRUE) |>
  dplyr::slice_head(n=1) |>
  dplyr::select(nhs_number, lipid_strat=event_desc)
```

## cholesterol measurements
```{r cholesterol_levels, results="markup"}
# days from ACS event in which to look for measurement data
cholesterol_blanking = 180 #days
#lipid strategy
cholesterol_control <- all_subsequent_events |>
  # only take cholesterol measurement events
  dplyr::filter(grepl("cholesterol_\\d+", event_desc)) |>
  # only take events within the blanking period
  dplyr::filter(event_start < (index_end + lubridate::duration(cholesterol_blanking, units="days"))) |>
  dplyr::mutate(value = as.numeric(stringr::str_extract(event_desc, "\\d+")), 
                event_desc = cut(value, 
                                 breaks=seq(0,14,2), 
                                 labels=paste0(seq(0,14,2),"<chol<=",dplyr::lead(seq(0,14,2)))[1:7], right=T)) |>
  # take the best/lowest cholesterol
  dplyr::group_by(nhs_number) |>
  dplyr::arrange(event_desc, .by_group = TRUE) |>
  dplyr::slice_head(n=1) |>
  dplyr::select(nhs_number, chol_control=event_desc)
```

## Survival (all-cause death) by lipid prescribing at 4 months post discharge
```{r survival_by_lipid_prescribing, results="markup"}
# look at the unique outcome options and choose those to assess; filter some stuff out to make it easier
#unique(all_subsequent_events$event_desc[!grepl("elective|emergency|[A-Z]\\d+", all_subsequent_events$event_desc)])

#survival data
outcome_groupings = list("any_death" = "^death")

surf_data <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number") |>
  dplyr::left_join(lipid_strat, by="nhs_number") |>
  dplyr::mutate(lipid_strat = as.character(lipid_strat),
                lipid_strat = tidyr::replace_na(lipid_strat,"none"),
                lipid_strat = dplyr::if_else(tstop<lipid_strat_blanking, "blanking_window", lipid_strat), 
                # NB dont just copy the above line for things that could happen more than once!!!!
                # Fine here as death can't occur twice
                lipid_strat = factor(lipid_strat, 
                                     levels=c("high_statin", "subopt_statin","none", "blanking_window"),
                                     labels=c("high_statin", "subopt_statin","none", "blanking_window")))
                
# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(surf_data$tstart, surf_data$tstop, surf_data$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + lipid_strat, data=surf_data)
# Survival table
survtbl <- summary(surv_fit)

# Plot 
km_plot_lipids <- ggsurvplot(
           fit          = surv_fit,
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = c("darkgreen", "orange3", "darkred", "darkgrey"),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           #xlim = c(0.0, 366.0),
           legend       = c(0.7,0.3),
           legend.title = "",
           legend.labs = c("High dose statin", "Sub-optimal dose statin", "No statin", "Blanking window event"),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_lipids

```

## Survival (all-cause death) by cholesterol control
```{r survival_by_cholesterol_control, results="markup"}
# look at the unique outcome options and choose those to assess; filter some stuff out to make it easier
#unique(all_subsequent_events$event_desc[!grepl("elective|emergency|[A-Z]\\d+", all_subsequent_events$event_desc)])

#survival data
outcome_groupings = list("any_death" = "^death")

surf_data <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number") |>
  dplyr::left_join(cholesterol_control, by="nhs_number") |>
  dplyr::mutate(chol_control = as.character(chol_control),
                chol_control = tidyr::replace_na(chol_control,"not measured"),
                chol_control = dplyr::if_else(tstop<cholesterol_blanking, "blanking_window", chol_control), 
                # NB dont just copy the above line for things that could happen more than once!!!!
                # Fine here as death can't occur twice
                chol_control = factor(chol_control, 
                                      levels=c("blanking_window","not measured",levels(cholesterol_control$chol_control)),
                                      labels=c("blanking_window","not measured",levels(cholesterol_control$chol_control))
                                      ))

#TODO filter out patients before the cholesterol data epoch





# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(surf_data$tstart, surf_data$tstop, surf_data$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + chol_control, data=surf_data)
# Survival table
survtbl <- summary(surv_fit)

# Plot 
km_plot_cholesterol <- ggsurvplot(
           fit          = surv_fit,
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = c("darkgrey", "purple3", colorRampPalette(c("orange", "orange3", "brown"))(length(surv_fit$strata)-2)),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           #xlim = c(0.0, 366.0),
           # legend       = c(0.7,0.3),
           # legend.title = "",
           # legend.labs = c("High dose statin", "Sub-optimal dose statin", "No statin", "Blanking window event"),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_cholesterol

```


## MACCE by lipid prescribing at 4 months post discharge
```{r macce_by_lipid_prescribing, results="markup"}
outcome_groupings = list("macce" = c("death_acs_[a-z]+", 
                                     "death_[a-z]+_cardiomyopathy",
                                     "death_heart_failure",
                                     "death_ischaemic_stroke",
                                     "death_ventricular_arrhy",
                                     "death_atrial_fib",
                                     "death_atrial_arrhy",
                                     "death_cardiomegaly",
                                     "death_periph_vasc_disease",
                                     "death_presence_of_coronary_stent",
                                     "death_presence_of_cabg",
                                     "death_presence_of_prosthetic_heart_valve",
                                     "death_presence_of_cied",
                                     "death_conduction_disease",
                                     "death_[a-z]+_valve_regurgitation",
                                     "death_[a-z]+_valve_stenosis",
                                     "death_cardiac_arrest", 
                                     "^acs_[a-z]+_[a-z]*_emergency$",
                                     "ischaemic_stroke",
                                     "^angiogram",
                                     "^pci", 
                                     "^cabg"))

surf_data <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number") |>
  dplyr::left_join(lipid_strat, by="nhs_number") |>
  dplyr::mutate(lipid_strat = as.character(lipid_strat),
                lipid_strat = tidyr::replace_na(lipid_strat,"none"),
                lipid_strat = dplyr::if_else(tstop<lipid_strat_blanking, "blanking_window", lipid_strat), 
                # NB dont just copy the above line for things that could happen more than once!!!!
                # Fixed with below group by which causes anyone that has an event in the blanking period to have ALL subsequent events removed
                lipid_strat = factor(lipid_strat, 
                                     levels=c("high_statin", "subopt_statin","none", "blanking_window"),
                                     labels=c("high_statin", "subopt_statin","none", "blanking_window"))) |>
  dplyr::group_by(nhs_number) |>
  dplyr::mutate(lipid_strat = dplyr::if_else(rep(any(lipid_strat=="blanking_window"), dplyr::n()), "blanking_window", lipid_strat))

# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(surf_data$tstart, surf_data$tstop, surf_data$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + fudge_cambridge_segment, data=surf_data)
# Survival table
survtbl <- summary(surv_fit)

# Plot 
km_plot_macce <- ggsurvplot(
           fit          = surv_fit,
           surv.scale   = "percent",
           xscale       = 365.25,
           break.time.by= 365.25,
           conf.int      = TRUE,
           conf.int.alpha=0.25,
           palette      = colorRampPalette(c("black", "red"))(length(surv_fit$strata)),
           censor.shape ="",
           xlab = "Time from index ACS event (years)",
           ylab = "Survival",
           ylim = c(0.0, 1.0),
           #xlim = c(0.0, 366.0),
           # legend       = c(0.7,0.3),
           # legend.title = "",
           # legend.labs = c("High dose statin", "Sub-optimal dose statin", "No statin", "Blanking window event"),
           risk.table = TRUE,
           ggtheme      = theme_classic())
km_plot_macce
```


## MACCE by cholesterol control post discharge
```{r macce_by_cholesterol_control, results="markup"}
# outcome_groupings = list("macce" = c("death_acs_[a-z]+", 
#                                      "death_[a-z]+_cardiomyopathy",
#                                      "death_heart_failure",
#                                      "death_ischaemic_stroke",
#                                      "death_ventricular_arrhy",
#                                      "death_atrial_fib",
#                                      "death_atrial_arrhy",
#                                      "death_cardiomegaly",
#                                      "death_periph_vasc_disease",
#                                      "death_presence_of_coronary_stent",
#                                      "death_presence_of_cabg",
#                                      "death_presence_of_prosthetic_heart_valve",
#                                      "death_presence_of_cied",
#                                      "death_conduction_disease",
#                                      "death_[a-z]+_valve_regurgitation",
#                                      "death_[a-z]+_valve_stenosis",
#                                      "death_cardiac_arrest", 
#                                      "^acs_[a-z]+_[a-z]*_emergency$",
#                                      "ischaemic_stroke",
#                                      "^angiogram",
#                                      "^pci", 
#                                      "^cabg"))
# 
# surf_data <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
#   dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, fudge_cambridge_segment), by="nhs_number") |>
#   dplyr::left_join(lipid_strat, by="nhs_number") |>
#   dplyr::mutate(lipid_strat = as.character(lipid_strat),
#                 lipid_strat = tidyr::replace_na(lipid_strat,"none"),
#                 lipid_strat = dplyr::if_else(tstop<lipid_strat_blanking, "blanking_window", lipid_strat), 
#                 # NB dont just copy the above line for things that could happen more than once!!!!
#                 # Fixed with below group by which causes anyone that has an event in the blanking period to have ALL subsequent events removed
#                 lipid_strat = factor(lipid_strat, levels=c("high_statin", "subopt_statin","none", "blanking_window"))) |>
#   dplyr::group_by(nhs_number) |>
#   dplyr::mutate(lipid_strat = dplyr::if_else(rep(any(lipid_strat=="blanking_window"), dplyr::n()), "blanking_window", lipid_strat))


#TODO filter out patients before the cholesterol data epoch



# 
# # Create the Survival object - for any readmission
# surv_tt_obj <- survival::Surv(surf_data$tstart, surf_data$tstop, surf_data$status)
# # Survival fit
# surv_fit <- survfit(surv_tt_obj ~ outcome + fudge_cambridge_segment, data=surf_data)
# # Survival table
# survtbl <- summary(surv_fit)
# 
# # Plot 
# km_plot_macce <- ggsurvplot(
#            fit          = surv_fit,
#            surv.scale   = "percent",
#            xscale       = 365.25,
#            break.time.by= 365.25,
#            conf.int      = TRUE,
#            conf.int.alpha=0.25,
#            palette      = colorRampPalette(c("black", "red"))(length(surv_fit$strata)),
#            censor.shape ="",
#            xlab = "Time from index ACS event (years)",
#            ylab = "Survival",
#            ylim = c(0.0, 1.0),
#            #xlim = c(0.0, 366.0),
#            # legend       = c(0.7,0.3),
#            # legend.title = "",
#            # legend.labs = c("High dose statin", "Sub-optimal dose statin", "No statin", "Blanking window event"),
#            risk.table = TRUE,
#            ggtheme      = theme_classic())
# km_plot_macce
```



## Cardiovascular emergency readmission by index procedural status
Look at the cardiovascular readmissions split by whether the patient underwent an invasive procedure
```{r cv_readmission_by_index_procedure_status, results="markup"}
# look at the unique outcome options and choose those to assess; filter some stuff out to make it easier
#unique(all_subsequent_events$event_desc[!grepl("elective|emergency|[A-Z]\\d+", all_subsequent_events$event_desc)])

outcome_groupings = list("emergency_acs_readmission" = c("^acs_[a-z]+_[a-z]*_emergency$"),
                         "emergency_angio" = c("angiogram_emergency"), 
                         "emergency_pci"   = c("pci_emergency"),
                         "emergency_cabg"  = c("(?<!presence_of_)cabg_emergency"))
# check which outcomes you're about to look at (what have the regexes above found?)
unique(all_subsequent_events$event_desc)[grepl(paste0(unlist(outcome_groupings),collapse="|"),unique(all_subsequent_events$event_desc),perl=TRUE)]
# create data
surf_data <- acsprojectns::create_survival_timings(all_subsequent_events, outcome_groupings) |> 
  dplyr::left_join(dat_demographics |> dplyr::select(nhs_number, age, fudge_cambridge_segment), by="nhs_number") |>
  dplyr::left_join(index_acs_main |> dplyr::select(nhs_number, primary_diagnosis, any_angiogram), by="nhs_number") |>
  dplyr::mutate(any_angiogram = factor(dplyr::if_else(!is.na(any_angiogram),T,F),
                                       levels = c(T,F),
                                       labels = c("Index angiogram/PCI", "No index angiogram/PCI")), 
                age_cat = cut(age, breaks=c(0,40,60,80,120), labels=c("<40", "40-59", "60-79","80+"), right=F), 
                primary_diagnosis = icdb::group_string(primary_diagnosis)) |>
  
  #TODO NB this filter 
  dplyr::filter(grepl("nstemi|unstable_angina", primary_diagnosis))
                
# Create the Survival object - for any readmission
surv_tt_obj <- survival::Surv(surf_data$tstart, surf_data$tstop, surf_data$status)
# Survival fit
surv_fit <- survfit(surv_tt_obj ~ outcome + any_angiogram, data=surf_data)
# Survival table
survtbl <- summary(surv_fit)

# Plot 
km_plot <- ggsurvplot(
             fit          = surv_fit,
             facet.by     = c("outcome", "age_cat"),
             surv.scale   = "percent",
             xscale       = 365.25,
             break.time.by= 365.25,
             conf.int      = TRUE,
             conf.int.alpha=0.25,
             palette      = c("darkgreen", "darkred"),
             censor.shape ="",
             title = "Emergency ACS or coronary procedure readmission by index ACS procedure and age",
             xlab = "Time from index ACS event (years)",
             ylab = "Freedom from outcome",
             ylim = c(0.50, 1.0),
             legend       = c(0.8,0.2),
             legend.title = "",
             legend.labs =  levels(surf_data$any_angiogram),
             # risk.table = TRUE, 
             ggtheme      = theme_classic())
km_plot

```

